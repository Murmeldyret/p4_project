Package postfix; 

Helpers
    //Do not put Tokens/terminals in here
    number = ['0' .. '9']+;
    all = [00 .. 127];
    
    // different ways of producing end of line on different OS'
    cr = 13;
    lf = 10;
    tab = 9;
    eol = cr | lf | cr lf ;
    not_eol = [all -[cr + lf]];
    sign = '+' | '-';
    sort_order_asc = 'asc';
    sort_order_dsc = 'desc';

    //Operators
    op_plus = '+';
    op_minus = '-';
    op_mult = '*';
    op_div = '/';
    op_mod = '%';

    arit_bin_infix_op = op_plus | op_minus | op_mult | op_div | op_mod ;
    //Boolean Operators
    bop_lthan = '<';
    bop_lethan = '<=';
    bop_gthan = '>';
    bop_gethan = '>=';
    bop_eq = '==';
    bop_and = 'and';
    bop_or = 'or';

    bool_bin_infix_op = bop_lthan | bop_lethan | bop_gthan | bop_gethan | bop_eq | bop_and | bop_or ;
    bop_not = 'not';
    
    //special operators
    sop_sum = 'sum';
    sop_filter = 'filter';
    sop_groupby = 'groupby';
    sop_mean = 'mean';
    sop_sort = 'sort';
    sop_count = 'count';

Tokens
    //for tokens in the program
    newline = eol;

    //comment
    comment = ('#' not_eol* eol); 
    //braces and parens
    l_par = '(';
    r_par = ')';
    l_cbrack = '{';
    r_cbrack = '}';
    l_brack = '[';
    r_brack = ']';

    //types
    string = ('"' '"');
    intnum = sign? (number)+ ;
    floatnum = sign? (number)+ '.' (number)+;
    bool = 'true' | 'false';
    type = ('int' | 'bool' | 'float' | 'string' | 'csv' | 'char' | 'array');
    char = 39 '.' 39;

    id = (['A' .. 'Z'] ['a' .. 'z'])(['A' .. 'Z'] ['a' .. 'z'] ['0' .. '9'])*;
    blank = (' ' | 13 | 10)+;

    // kan måske flyttes til tokens hvis operatorer flyttes til helpers, dermed vil Productions blive simplere
    bin_infix_op = arit_bin_infix_op | bool_bin_infix_op ;
    
    // skal der være andre prefix operatorer?
    unary_prefix_op =
        bop_not |
        sop_filter |
        sop_groupby |
        sop_mean |
        sop_count ;

    //special Operators
    op_assign = '=';
    sop_dot = '.';



    //keywords
    kw_as = 'as';
    kw_import = 'import';
    kw_separated_by = 'seperated_by';
    kw_for = 'for';
    kw_while = 'while';
    kw_in = 'in';
    kw_if = 'if';
    kw_else = 'else';
    kw_sort_order = sort_order_asc | sort_order_dsc;


Ignored Tokens
    blank,
    comment;

Productions
    program =
        {program} stmts;
        
    stmts =
        {statements} stmt newline stmts | ;

    stmt =
        {import_stmt} import_t |
        {declaration} type id op_assign expr | 
        {assignment_statement} assignment |
        {for_loop} kw_for id kw_in val block |
        {while_loop} kw_while expr block |
        {control_statement} kw_if expr block in_control_stmt ;

    block =
       {block_stmt} l_cbrack stmts r_cbrack ;

    in_control_stmt =
       {elif_statement} kw_else kw_if expr block |
       {else_statement} else_statement;
    
    else_statement =
       {else_block_statement} kw_else block | ;
    
    assignment =
        {assign} id op_assign expr;

    expr =
       {expr_val_prime} val expr_prime | ;
    
    expr_prime = 
       {expr_prime_operator_val_prime} bin_infix_op val expr_prime | ;
    
    val = 
       {val_id} id |
        {val_floatnum} floatnum |
        {val_intnum} intnum |
        {val_string} string |
        {val_bool} bool ;


    import_t =
        {import_without_seperator} kw_import string kw_as id |
        {import_with_seperator} kw_import string kw_separated_by char kw_as id;