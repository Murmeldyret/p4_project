Package postfix; 

Helpers
    //Do not put Tokens/terminals in here
    number = ['0' .. '9']+;
    nonnumber = ['_'+[['a'..'z']+['A'..'Z']]] ;
    all = [00 .. 127];

    //reserved_keywords = ('filter' | 'sum' | 'groupby' | 'mean' | 'sort' | 'count' | 'as' | 'import' | 'export' | 'print' | 'separated_by' | 'for' | 'while' | 'in' | 'if' | 'else' | 'asc' | 'desc' | 'to' | 'const' | 'function' | 'return' | 'break' | 'add' | 'remove' | 'remov_at' | 'insert' | 'column' | 'row') ;
    
    // different ways of producing end of line on different OS'
    cr = 13;
    lf = 10;
    tab = 9;
    eol = cr | lf | cr lf ;
    not_eol = [all -[cr + lf]];
    sign = '-';

Tokens
    //for tokens in the program
    newline = eol;
    semi = ';';
    //comment
    comment = ('#' not_eol* eol); 
    //braces and parens
    l_par = '(';
    r_par = ')';
    l_cbrack = '{';
    r_cbrack = '}';
    l_brack = '[';
    r_brack = ']';

    //types
    string = ('"' [not_eol-'"']* '"');
    intnum = sign? (number)+ ;
    floatnum = sign? (number)+ '.' (number)+;
    bool = 'true' | 'false';
    type = ('int' | 'bool' | 'float' | 'string' | 'csv' | 'char' | 'void');
    char = 39 '.' 39;

    //Keywords
    kw_as = 'as';
    kw_import = 'import';
    kw_export = 'export';
    kw_print = 'print';
    kw_separated_by = 'seperated_by';
    kw_for = 'for';
    kw_while = 'while';
    kw_in = 'in';
    kw_if = 'if';
    kw_else = 'else';
    kw_sort_order_asc = 'asc';
    kw_sort_order_dsc = 'desc';
    kw_to = 'to';
    kw_const = 'const';
    kw_function = 'function';
    kw_return = 'return';
    kw_break = 'break';
    kw_array = 'array';
    
    blank = (' ' | 13 | 10)+;

    //Operators
    op_assign = '=';
    op_plus = '+';
    op_minus = '-';
    op_mult = '*';
    op_div = '/';
    op_mod = '%';

    //Boolean Operators
    bop_lthan = '<';
    bop_lethan = '<=';
    bop_gthan = '>';
    bop_gethan = '>=';
    bop_eq = '==';
    bop_neq = '!=';
    bop_and = 'and';
    bop_or = 'or';
    bop_not = 'not';

    //Special Operators
    sop_dot = '.';
    sop_comma = ',';
    sop_sum = 'sum';
    sop_filter = 'filter';
    sop_groupby = 'groupby';
    sop_mean = 'mean';
    sop_sort = 'sort';
    sop_count = 'count';


    //array Keywords
    kw_add = 'add';
    kw_remove_last = 'remove_last';
    kw_remove_at = 'remove_at';
    kw_insert = 'insert';

    //csv operations
    kw_column = 'column';
    kw_row = 'row';
    id = (nonnumber(nonnumber|number)*);

Ignored Tokens
    blank,
    newline,
    comment;

Productions
    program =
     {program} stmts {-> New program.program (stmts) };

    stmts {-> P.stmts  } =
     {statements} stmt semi stmts {-> New stmts.statements (stmt , semi , stmts  )  }   
    | {-> New stmts ( )  } ;

    stmt =
     {import_stmt}                  import                              {-> import.stmt}   
    | {declaration}                 dcl                                 {-> New stmt.declaration (dcl  )  }   
    | {assignment_statement_stmt}   assignment                          {-> assignment.stmt  }   
    | {function_call}               function_call                       {-> New stmt.function_call(function_call) }
    | {array_operations}            array_op                            {-> New stmt.array_operations (array_op  )  }   
    | {for_loop}                    kw_for val kw_in id block           {-> New stmt.for_loop (kw_for , val , kw_in , id , block  )  }   
    | {while_loop}                  kw_while expr block                 {-> New stmt.while_loop (kw_while , expr , block  )  }   
    | {control_statement}           kw_if expr block in_control_stmt    {-> New stmt.control_statement (kw_if , expr , block , in_control_stmt  )  }   
    | {print_statement}             kw_print expr                       {-> New stmt.print_statement (kw_print , expr  )  }   
    | {csv_operation}               csv_op                              {-> New stmt.csv_operation (csv_op  )  }   
    | {export_statement}            kw_export id kw_to expr             {-> New stmt.export_statement (kw_export , id , kw_to , expr  )  }   
    | {return_stmt}                 return                              {-> return.stmt}   
    | {break_statement}             kw_break                            {-> New stmt.break_statement (kw_break  )  } ;

    import {-> stmt  } =
     {import_without_seperator} kw_import expr kw_as id                       {-> New stmt.import_without_seperator (kw_import , expr , kw_as , id )  }   
    | {import_with_seperator}   kw_import expr kw_separated_by char kw_as id  {-> New stmt.import_with_seperator (kw_import , expr , kw_separated_by , char , kw_as , id  )  } ;

    dcl =
     {variable_declaration_initialization}  type id op_assign expr                                                  {-> New dcl.variable_declaration_initialization (type , id , op_assign , expr  )  }   
    | {variable_declaration_array}          type kw_array id                                                        {-> New dcl.variable_declaration_array (type , kw_array, id )  }   
    | {variable_declaration}                type id                                                                 {-> New dcl.variable_declaration (type , id  )  }
    | {variable_declaration_array_init}     type kw_array id op_assign array_expr                                   {-> New dcl.variable_declaration_array_init (type, kw_array, id, op_assign, array_expr)}
    | {const_declaration_initialization}    kw_const type id op_assign expr                                         {-> New dcl.const_declaration_initialization (kw_const , type , id , op_assign , expr  )  }   
    | {function_declaration}                type kw_function id l_par function_param r_par block                    {-> New dcl.function_declaration (type , kw_function , id , function_param , block )  } ;

    function_param {-> P.function_param  } =
     {function_param} dcl function_param_prime {-> New function_param.function_param (dcl , function_param_prime  )  }   
    | {-> New function_param ( )  } ;

    function_param_prime {-> P.function_param_prime  } =
     {function_param_prime} sop_comma dcl function_param_prime {-> New function_param_prime.function_param_prime (sop_comma , dcl , function_param_prime  )  }   
    | {-> New function_param_prime ( )  } ;

    return {-> stmt  } =
     {return} kw_return expr {-> New stmt.return (kw_return , expr  )  } ;

    function_call_param {-> P.function_call_param  } =
     {function_call_param} expr function_call_param_prime {-> New function_call_param.function_call_param (expr , function_call_param_prime  )  }   
    | {-> New function_call_param ( )  } ;

    function_call_param_prime {-> P.function_call_param_prime  } =
     {function_call_param_prime} sop_comma expr function_call_param_prime {-> New function_call_param_prime.function_call_param_prime (sop_comma , expr , function_call_param_prime  )  }   
    | {-> New function_call_param_prime ( )  } ;

    function_call =
     {function_call} id l_par function_call_param r_par ;

    block {-> P.block  } =
     {block_stmt} l_cbrack stmts r_cbrack {-> New block.block_stmt ( stmts )  };

    in_control_stmt {-> P.in_control_stmt  } =
     {elif_statement}   kw_else kw_if expr block in_control_stmt    {-> New in_control_stmt.elif_statement (kw_else , kw_if , expr , block, in_control_stmt  )  }   
    | {else_statement}  else_statement                              {-> New in_control_stmt.else_statement (else_statement  )  } ;

    else_statement {-> P.else_statement  } =
     {else_block_statement} kw_else block {-> New else_statement.else_block_statement (kw_else , block  )  }   
    | {-> New else_statement ( )  } ;

    assignment {-> stmt  } =
     {assign} id indexing op_assign expr {-> New stmt.assign (id , indexing , op_assign , expr  )  } ;

    expr {-> P.expr  } =
      {aexprvalprimeexpr}  bop_not? type_cast? val expr_prime  {-> New expr.expr_val_prime (bop_not , type_cast, val , expr_prime  )  }   
    | {expr_special}        special_expr id         {-> New expr.expr_special (special_expr , id  )  }   
    | {expr_array}          array_expr              {-> New expr.expr_array (array_expr  )  } ;

    expr_prime {-> P.expr_prime  } =
     {expr_prime_operator_val_prime}    bin_infix_op val expr_prime {-> New expr_prime.expr_prime_operator_val_prime (bin_infix_op , val , expr_prime  )  }   
    | {-> New expr_prime ( )  } ;

    type_cast =
    {type_cast} l_par type r_par {-> New type_cast.type_cast (type)};

    csv_op {-> csv_op  } =
     {csv_operation_add}        csv_add         {-> csv_add.csv_op }   
    | {csv_operation_remove}    csv_remove      {-> csv_remove.csv_op  }   
    | {csv_operation_remove_at} csv_remove_at   {-> csv_remove_at.csv_op  }   
    | {csv_operation_insert}    csv_insert      {-> csv_insert.csv_op  } ;

    csv_add {-> csv_op  } =
     {add_to_csv} kw_add orientation expr? array_expr kw_in id {-> New csv_op.add_to_csv (kw_add , orientation, expr , array_expr , kw_in , id  )  } ;

    csv_remove {-> csv_op   } =
     {remove_from_csv} kw_remove_last orientation kw_in id {-> New csv_op.remove_from_csv (kw_remove_last , orientation , kw_in , id  )  } ;

    csv_remove_at {-> csv_op   } =
     {remove_at_from_csv} kw_remove_at orientation val kw_in id {-> New csv_op.remove_at_from_csv (kw_remove_at , orientation , val , kw_in , id  )  } ;

    csv_insert {-> csv_op   } =
     {insert_from_csv} kw_insert orientation expr? val array_expr kw_in id {-> New csv_op.insert_from_csv (kw_insert , orientation, expr , val , array_expr , kw_in , id  )  } ;

    orientation {-> P.orientation  } =
     {csv_orientation_row}      kw_row      {-> New orientation.csv_orientation_row (kw_row  )  }   
    | {csv_orientation_column}  kw_column   {-> New orientation.csv_orientation_column (kw_column  )  } ;

    indexing {-> P.indexing  } =
     {indexing} l_brack expr r_brack indexing {-> New indexing.indexing ( expr , indexing  )  }   
    | {-> New indexing ( )  } ;

    array_expr {-> P.array_expr  } =
     {array_expr_val_prime} l_brack expr array_expr_prime r_brack {-> New array_expr.array_expr_val_prime ( expr , array_expr_prime  )  } ;

    array_expr_prime {-> P.array_expr_prime  } =
     {array_expr_prime_extra} sop_comma expr array_expr_prime {-> New array_expr_prime.array_expr_prime_extra (sop_comma , expr , array_expr_prime  )  }   
    | {-> New array_expr_prime ( )  } ;

    array_op {-> array_op  } =
     {array_operation_add}          array_add       {-> array_add.array_op  }   
    | {array_operation_remove}      array_remove    {-> array_remove.array_op  }   
    | {array_operation_remove_at}   array_remove_at {-> array_remove_at.array_op }   
    | {array_operation_insert}      array_insert    {-> array_insert.array_op } ;

    array_add {-> array_op  } =
     {add_to_array} kw_add array_expr kw_to id {-> New array_op.add_to_array (kw_add , array_expr, kw_to, id )  } ;

    array_remove {-> array_op   } =
     {remove_from_array} kw_remove_last kw_in id {-> New array_op.remove_from_array (kw_remove_last , kw_in , id  )  } ;

    array_remove_at {-> array_op   } =
     {remove_at_from_array} kw_remove_at indexing kw_in id {-> New array_op.remove_at_from_array (kw_remove_at , indexing , kw_in , id  )  } ;

    array_insert {-> array_op } =
     {insert_to_array} kw_insert expr array_expr kw_in id {-> New array_op.insert_to_array (kw_insert , expr , array_expr , kw_in , id  )  } ;

    val {-> val  } =
     {val_id}               id              {-> New val.val_id (id  )  }  
    | {val_function_call}   function_call   {-> New val.val_function_call(function_call) }
    | {val_floatnum}        floatnum        {-> New val.val_floatnum (floatnum  )  }   
    | {val_intnum}          intnum          {-> New val.val_intnum (intnum  )  }   
    | {val_string}          string          {-> New val.val_string (string  )  }   
    | {val_bool}            bool            {-> New val.val_bool (bool  )  } ;

    bin_infix_op {-> P.bin_infix_op  } =
     {plus_infix}                   op_plus     {-> New bin_infix_op.plus_infix (op_plus  )  }   
    | {minus_infix}                 op_minus    {-> New bin_infix_op.minus_infix (op_minus  )  }   
    | {multiplication_infix}        op_mult     {-> New bin_infix_op.multiplication_infix (op_mult  )  }   
    | {division_infix}              op_div      {-> New bin_infix_op.division_infix (op_div  )  }   
    | {modulo_infix}                op_mod      {-> New bin_infix_op.modulo_infix (op_mod  )  }   
    | {and_infix}                   bop_and     {-> New bin_infix_op.and_infix (bop_and  )  }   
    | {or_infix}                    bop_or      {-> New bin_infix_op.or_infix (bop_or  )  }   
    | {equality_infix}              bop_eq      {-> New bin_infix_op.equality_infix (bop_eq  )  }   
    | {greater_than_infix}          bop_gthan   {-> New bin_infix_op.greater_than_infix (bop_gthan  )  }   
    | {greater_than_equal_infix}    bop_gethan  {-> New bin_infix_op.greater_than_equal_infix (bop_gethan  )  }   
    | {less_than_infix}             bop_lthan   {-> New bin_infix_op.less_than_infix (bop_lthan  )  }   
    | {less_than_equal_infix}       bop_lethan  {-> New bin_infix_op.less_than_equal_infix (bop_lethan  )  }   
    | {not_equal_infix}             bop_neq     {-> New bin_infix_op.not_equal_infix (bop_neq  )  } ;

    special_expr {-> P.special_expr  } =
     {speical_expression} special_syntax special_expr_prime {-> New special_expr.speical_expression (special_syntax , special_expr_prime  )  } ;

    special_expr_prime {-> P.special_expr_prime  } =
     {special_expr_prime} special_syntax special_expr_prime {-> New special_expr_prime.special_expr_prime (special_syntax , special_expr_prime  )  }   
    | {-> New special_expr_prime ( )  } ;

    special_syntax {-> special_syntax  } =
     {sum_op}       sum     {-> sum.special_syntax  }   
    | {filter_op}   filter  {-> filter.special_syntax  }   
    | {mean_op}     mean    {-> mean.special_syntax  }   
    | {count_op}    count   {-> count.special_syntax  }   
    | {sort_op}     sort    {-> sort.special_syntax  } ;

    sum {-> special_syntax  } =
     {sum} sop_sum l_par expr r_par {-> New special_syntax.sum (sop_sum , expr )  } ;

    filter {-> special_syntax } =
     {filter} sop_filter l_par expr sop_comma dcl filterexpr r_par {-> New special_syntax.filter (sop_filter ,  expr , sop_comma , dcl, filterexpr)  } ;

    filterexpr =
     {filterexpr} sop_comma expr {-> New filterexpr.filterexpr (sop_comma, expr )} ;

    mean {-> special_syntax } =
     {mean} sop_mean l_par expr r_par {-> New special_syntax.mean (sop_mean, expr)  } ;

    count {-> special_syntax  } =
     {count} sop_count{-> New special_syntax.count (sop_count)  } ;

    sort {-> special_syntax } =
     {sort_asc}     sop_sort l_par expr sop_comma kw_sort_order_asc r_par   {-> New special_syntax.sort_asc (sop_sort , expr, sop_comma, kw_sort_order_asc )  }   
    | {sort_desc}   sop_sort l_par expr sop_comma kw_sort_order_dsc r_par   {-> New special_syntax.sort_desc (sop_sort , expr, sop_comma, kw_sort_order_dsc )  }   
    | {sort}        sop_sort l_par expr r_par                               {-> New special_syntax.sort (sop_sort, expr)  } ;

Abstract Syntax Tree
    program =
        {program} stmts;
        
    stmts =
        {statements} stmt semi stmts 
        | ;

    stmt =
        {import_without_seperator}  kw_import expr kw_as id 
        | {import_with_seperator}   kw_import expr kw_separated_by char kw_as id 
        | {declaration}             dcl 
        | {assign}                  id indexing op_assign expr 
        | {function_call}           function_call
        | {array_operations}        array_op 
        | {for_loop}                kw_for val kw_in id block 
        | {while_loop}              kw_while expr block 
        | {control_statement}       kw_if expr block in_control_stmt 
        | {csv_operation}           csv_op 
        | {print_statement}         kw_print expr 
        | {export_statement}        kw_export id kw_to expr 
        | {return}                  kw_return expr 
        | {break_statement}         kw_break ;

    dcl =
        {variable_declaration_initialization}   type id op_assign expr 
        | {variable_declaration_array}          type kw_array id  
        | {variable_declaration}                type id 
        | {variable_declaration_array_init}     type kw_array id op_assign array_expr
        | {const_declaration_initialization}    kw_const type id op_assign expr 
        | {function_declaration}                type kw_function id function_param block ;

    function_param = 
        {function_param} dcl function_param_prime 
        | ;

    function_param_prime =
        {function_param_prime} sop_comma dcl function_param_prime 
        | ;

        
    function_call_param = 
        {function_call_param} expr function_call_param_prime 
        | ;

    function_call_param_prime =
        {function_call_param_prime} sop_comma expr function_call_param_prime 
        | ;

    function_call =
     {function_call} id l_par function_call_param r_par ;

    block =
       {block_stmt} stmts ;

    in_control_stmt =
       {elif_statement}     kw_else kw_if expr block in_control_stmt 
       | {else_statement}   else_statement;
    
    else_statement =
       {else_block_statement} kw_else block 
       | ;

    expr = 
         {expr_val_prime}  bop_not? type_cast? val expr_prime 
       | {expr_special}     special_expr id 
       | {expr_array}       array_expr;
    
    expr_prime = 
        {expr_prime_operator_val_prime}      bin_infix_op val expr_prime 
        | ;

    type_cast =
        {type_cast} type ;
    
    csv_op = 
        {add_to_csv}            kw_add orientation expr? array_expr kw_in id 
        | {remove_from_csv}     kw_remove_last orientation kw_in id 
        | {remove_at_from_csv}  kw_remove_at orientation val kw_in id 
        | {insert_from_csv}     kw_insert orientation expr? val array_expr kw_in id ;

    orientation = 
        {csv_orientation_row}       kw_row 
        | {csv_orientation_column}  kw_column ;

    //index indmad ændret fra val til expr
    indexing =
        {indexing} expr indexing 
        | ;

    array_expr = 
        {array_expr_val_prime} expr array_expr_prime ;

    array_expr_prime = 
        {array_expr_prime_extra} sop_comma expr array_expr_prime 
        | ;

    array_op =
        {add_to_array}              kw_add array_expr kw_to id
        | {remove_from_array}       kw_remove_last kw_in id 
        | {remove_at_from_array}    kw_remove_at indexing kw_in id 
        | {insert_to_array}         kw_insert expr array_expr kw_in id ;

    //måske skal function call ikke være value men expression i stedet, time will tell
    val = 
        {val_id}            id  
        | {val_function_call}   function_call
        | {val_floatnum}    floatnum 
        | {val_intnum}      intnum 
        | {val_string}      string 
        | {val_bool}        bool ;

    bin_infix_op = 
        {plus_infix}                    op_plus 
        | {minus_infix}                 op_minus 
        | {multiplication_infix}        op_mult 
        | {division_infix}              op_div 
        | {modulo_infix}                op_mod 
        | {and_infix}                   bop_and 
        | {or_infix}                    bop_or 
        | {equality_infix}              bop_eq 
        | {greater_than_infix}          bop_gthan 
        | {greater_than_equal_infix}    bop_gethan 
        | {less_than_infix}             bop_lthan 
        | {less_than_equal_infix}       bop_lethan 
        | {not_equal_infix}             bop_neq ;
    
    special_expr =
        {speical_expression} special_syntax special_expr_prime;

    special_expr_prime =
        {special_expr_prime} special_syntax special_expr_prime 
        | ;
    
    special_syntax =
        {sum}           sop_sum expr
        | {filter}      sop_filter expr sop_comma dcl filterexpr
        | {mean}        sop_mean expr
        | {count}       sop_count 
        | {sort_asc}    sop_sort expr sop_comma kw_sort_order_asc 
        | {sort_desc}   sop_sort expr sop_comma kw_sort_order_dsc 
        | {sort}        sop_sort expr;

    filterexpr =
        {filterexpr} sop_comma expr;
